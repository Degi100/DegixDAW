# VST Plugin Architecture - DegixDAW

**Erstellt:** 2025-10-17
**Version:** 1.0

---

## üîå VST Plugin Overview

### Purpose

Das DegixDAW VST3 Plugin dient als **Bridge zwischen DAW und Supabase Cloud**.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  VST Plugin Flow                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

User in DAW (Cubase)
  ‚îÇ
  ‚îú‚îÄ Opens VST Plugin
  ‚îú‚îÄ Logs in via Browser OAuth
  ‚îú‚îÄ Sees list of Projects
  ‚îú‚îÄ Selects Project
  ‚îú‚îÄ Downloads MIDI + Audio to DAW
  ‚îú‚îÄ Works on Project (mix, add FX)
  ‚îú‚îÄ Renders Mixdown
  ‚îî‚îÄ Uploads Mixdown back to Cloud
```

### Key Features

```
‚úÖ Login via OAuth (Browser-based)
‚úÖ Fetch User Projects from Supabase
‚úÖ Download MIDI files to DAW
‚úÖ Download Audio files to DAW
‚úÖ Upload Mixdowns to Cloud
‚úÖ Browse & Download Presets
‚úÖ Auto-token refresh
```

---

## üèóÔ∏è JUCE Project Structure

### Directory Layout

```
vst-plugin/
‚îú‚îÄ‚îÄ CMakeLists.txt              # CMake build config
‚îú‚îÄ‚îÄ JUCE/                       # JUCE submodule
‚îú‚îÄ‚îÄ Source/
‚îÇ   ‚îú‚îÄ‚îÄ PluginProcessor.h/cpp   # Audio processing logic
‚îÇ   ‚îú‚îÄ‚îÄ PluginEditor.h/cpp      # UI component
‚îÇ   ‚îú‚îÄ‚îÄ SupabaseClient.h/cpp    # HTTP client for Supabase
‚îÇ   ‚îú‚îÄ‚îÄ AuthManager.h/cpp       # OAuth flow
‚îÇ   ‚îú‚îÄ‚îÄ ProjectManager.h/cpp    # Project CRUD
‚îÇ   ‚îú‚îÄ‚îÄ FileDownloader.h/cpp    # Download logic
‚îÇ   ‚îú‚îÄ‚îÄ FileUploader.h/cpp      # Upload logic
‚îÇ   ‚îú‚îÄ‚îÄ LookAndFeel.h/cpp       # Custom UI theme
‚îÇ   ‚îî‚îÄ‚îÄ Utils.h/cpp             # Helper functions
‚îú‚îÄ‚îÄ Resources/
‚îÇ   ‚îî‚îÄ‚îÄ logo.png                # Plugin icon
‚îî‚îÄ‚îÄ builds/
    ‚îî‚îÄ‚îÄ VisualStudio2022/       # Generated by CMake
```

---

## üéõÔ∏è Plugin Components

### 1. PluginProcessor (Audio Core)

```cpp
// ============================================
// PluginProcessor.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include "SupabaseClient.h"
#include "AuthManager.h"
#include "ProjectManager.h"

class DegixDAWProcessor : public juce::AudioProcessor
{
public:
    DegixDAWProcessor();
    ~DegixDAWProcessor() override;

    //==============================================================================
    // Audio Processing (Passthrough - no audio effects)
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    //==============================================================================
    // Plugin State
    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;

    //==============================================================================
    // Editor
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    //==============================================================================
    // Plugin Info
    const juce::String getName() const override { return "DegixDAW"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    //==============================================================================
    // Programs (not used)
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return {}; }
    void changeProgramName(int, const juce::String&) override {}

    //==============================================================================
    // DegixDAW API
    AuthManager& getAuthManager() { return authManager; }
    ProjectManager& getProjectManager() { return projectManager; }
    SupabaseClient& getSupabaseClient() { return supabaseClient; }

private:
    //==============================================================================
    // Components
    AuthManager authManager;
    ProjectManager projectManager;
    SupabaseClient supabaseClient;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DegixDAWProcessor)
};
```

```cpp
// ============================================
// PluginProcessor.cpp
// ============================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

DegixDAWProcessor::DegixDAWProcessor()
    : AudioProcessor(BusesProperties()) // No audio buses (not an effect)
    , supabaseClient("https://your-project.supabase.co", "your-anon-key")
    , authManager(supabaseClient)
    , projectManager(supabaseClient)
{
}

DegixDAWProcessor::~DegixDAWProcessor()
{
}

void DegixDAWProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // Not processing audio
}

void DegixDAWProcessor::releaseResources()
{
    // Nothing to release
}

void DegixDAWProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    // Passthrough - don't modify audio
    juce::ignoreUnused(buffer, midiMessages);
}

void DegixDAWProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    // Save auth token + selected project ID
    auto state = authManager.getState();
    destData.append(state.data(), state.size());
}

void DegixDAWProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    // Restore auth token + selected project ID
    authManager.setState(data, sizeInBytes);
}

juce::AudioProcessorEditor* DegixDAWProcessor::createEditor()
{
    return new DegixDAWEditor(*this);
}

// Plugin Entry Point
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new DegixDAWProcessor();
}
```

---

### 2. PluginEditor (UI)

```cpp
// ============================================
// PluginEditor.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include "PluginProcessor.h"

class DegixDAWEditor : public juce::AudioProcessorEditor,
                       public juce::Button::Listener,
                       public juce::ListBoxModel
{
public:
    DegixDAWEditor(DegixDAWProcessor&);
    ~DegixDAWEditor() override;

    //==============================================================================
    void paint(juce::Graphics&) override;
    void resized() override;

    //==============================================================================
    // Button Listener
    void buttonClicked(juce::Button*) override;

    //==============================================================================
    // ListBox Model
    int getNumRows() override;
    void paintListBoxItem(int rowNumber, juce::Graphics&, int width, int height, bool rowIsSelected) override;
    void listBoxItemClicked(int row, const juce::MouseEvent&) override;

private:
    DegixDAWProcessor& processor;

    // UI Components
    juce::Label titleLabel;
    juce::TextButton loginButton{"Login"};
    juce::TextButton logoutButton{"Logout"};
    juce::TextButton refreshButton{"Refresh Projects"};
    juce::TextButton loadToDAWButton{"Load to DAW"};
    juce::TextButton uploadMixdownButton{"Upload Mixdown"};
    juce::ListBox projectListBox;
    juce::Label statusLabel;

    // State
    std::vector<ProjectInfo> projects;
    int selectedProjectIndex = -1;

    // Helper
    void updateUI();
    void login();
    void logout();
    void refreshProjects();
    void loadProjectToDAW();
    void uploadMixdown();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DegixDAWEditor)
};
```

```cpp
// ============================================
// PluginEditor.cpp
// ============================================
#include "PluginEditor.h"

DegixDAWEditor::DegixDAWEditor(DegixDAWProcessor& p)
    : AudioProcessorEditor(&p)
    , processor(p)
{
    setSize(600, 500);

    // Title
    titleLabel.setText("DegixDAW", juce::dontSendNotification);
    titleLabel.setFont(juce::Font(24.0f, juce::Font::bold));
    titleLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(titleLabel);

    // Buttons
    loginButton.addListener(this);
    logoutButton.addListener(this);
    refreshButton.addListener(this);
    loadToDAWButton.addListener(this);
    uploadMixdownButton.addListener(this);

    addAndMakeVisible(loginButton);
    addAndMakeVisible(logoutButton);
    addAndMakeVisible(refreshButton);
    addAndMakeVisible(loadToDAWButton);
    addAndMakeVisible(uploadMixdownButton);

    // Project List
    projectListBox.setModel(this);
    addAndMakeVisible(projectListBox);

    // Status
    statusLabel.setText("Not logged in", juce::dontSendNotification);
    addAndMakeVisible(statusLabel);

    updateUI();
}

DegixDAWEditor::~DegixDAWEditor()
{
}

void DegixDAWEditor::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colours::darkgrey);
}

void DegixDAWEditor::resized()
{
    auto bounds = getLocalBounds().reduced(10);

    titleLabel.setBounds(bounds.removeFromTop(40));
    bounds.removeFromTop(10);

    auto buttonArea = bounds.removeFromTop(40);
    loginButton.setBounds(buttonArea.removeFromLeft(100).reduced(2));
    logoutButton.setBounds(buttonArea.removeFromLeft(100).reduced(2));
    refreshButton.setBounds(buttonArea.removeFromLeft(120).reduced(2));
    loadToDAWButton.setBounds(buttonArea.removeFromLeft(120).reduced(2));
    uploadMixdownButton.setBounds(buttonArea.removeFromLeft(140).reduced(2));

    bounds.removeFromTop(10);
    projectListBox.setBounds(bounds.removeFromTop(300));

    bounds.removeFromTop(10);
    statusLabel.setBounds(bounds.removeFromTop(30));
}

void DegixDAWEditor::buttonClicked(juce::Button* button)
{
    if (button == &loginButton) login();
    else if (button == &logoutButton) logout();
    else if (button == &refreshButton) refreshProjects();
    else if (button == &loadToDAWButton) loadProjectToDAW();
    else if (button == &uploadMixdownButton) uploadMixdown();
}

void DegixDAWEditor::login()
{
    processor.getAuthManager().startOAuthFlow([this](bool success) {
        if (success) {
            statusLabel.setText("Logged in!", juce::dontSendNotification);
            refreshProjects();
        } else {
            statusLabel.setText("Login failed", juce::dontSendNotification);
        }
        updateUI();
    });
}

void DegixDAWEditor::logout()
{
    processor.getAuthManager().logout();
    projects.clear();
    projectListBox.updateContent();
    statusLabel.setText("Logged out", juce::dontSendNotification);
    updateUI();
}

void DegixDAWEditor::refreshProjects()
{
    statusLabel.setText("Loading projects...", juce::dontSendNotification);

    processor.getProjectManager().fetchProjects([this](std::vector<ProjectInfo> fetchedProjects) {
        projects = fetchedProjects;
        projectListBox.updateContent();
        statusLabel.setText(juce::String(projects.size()) + " projects loaded", juce::dontSendNotification);
    });
}

void DegixDAWEditor::loadProjectToDAW()
{
    if (selectedProjectIndex < 0 || selectedProjectIndex >= (int)projects.size()) {
        statusLabel.setText("Select a project first", juce::dontSendNotification);
        return;
    }

    auto& project = projects[selectedProjectIndex];
    statusLabel.setText("Loading project to DAW...", juce::dontSendNotification);

    processor.getProjectManager().loadProjectToDAW(project, [this](bool success) {
        if (success) {
            statusLabel.setText("Project loaded!", juce::dontSendNotification);
        } else {
            statusLabel.setText("Failed to load project", juce::dontSendNotification);
        }
    });
}

void DegixDAWEditor::uploadMixdown()
{
    // File chooser for WAV file
    auto chooser = std::make_shared<juce::FileChooser>("Select Mixdown", juce::File(), "*.wav");

    chooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this, chooser](const juce::FileChooser& fc) {
            auto file = fc.getResult();
            if (file.existsAsFile()) {
                statusLabel.setText("Uploading mixdown...", juce::dontSendNotification);

                processor.getProjectManager().uploadMixdown(projects[selectedProjectIndex], file, [this](bool success) {
                    if (success) {
                        statusLabel.setText("Mixdown uploaded!", juce::dontSendNotification);
                    } else {
                        statusLabel.setText("Upload failed", juce::dontSendNotification);
                    }
                });
            }
        });
}

void DegixDAWEditor::updateUI()
{
    bool isLoggedIn = processor.getAuthManager().isAuthenticated();
    loginButton.setEnabled(!isLoggedIn);
    logoutButton.setEnabled(isLoggedIn);
    refreshButton.setEnabled(isLoggedIn);
    loadToDAWButton.setEnabled(isLoggedIn && selectedProjectIndex >= 0);
    uploadMixdownButton.setEnabled(isLoggedIn && selectedProjectIndex >= 0);
}

int DegixDAWEditor::getNumRows()
{
    return (int)projects.size();
}

void DegixDAWEditor::paintListBoxItem(int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowIsSelected)
        g.fillAll(juce::Colours::lightblue);
    else
        g.fillAll(rowNumber % 2 == 0 ? juce::Colours::white : juce::Colours::lightgrey);

    if (rowNumber < (int)projects.size()) {
        auto& project = projects[rowNumber];
        g.setColour(juce::Colours::black);
        g.drawText(project.title, 10, 0, width - 10, height, juce::Justification::centredLeft);
    }
}

void DegixDAWEditor::listBoxItemClicked(int row, const juce::MouseEvent&)
{
    selectedProjectIndex = row;
    updateUI();
}
```

---

### 3. SupabaseClient (HTTP Client)

```cpp
// ============================================
// SupabaseClient.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include <curl/curl.h>
#include <nlohmann/json.hpp>

struct ProjectInfo {
    juce::String id;
    juce::String title;
    juce::String description;
    int bpm;
    juce::String status;
    std::vector<juce::String> trackIds;
};

class SupabaseClient
{
public:
    SupabaseClient(const juce::String& supabaseUrl, const juce::String& anonKey);
    ~SupabaseClient();

    //==============================================================================
    // Auth
    struct LoginResult {
        bool success;
        juce::String accessToken;
        juce::String refreshToken;
        juce::String errorMessage;
    };
    LoginResult login(const juce::String& email, const juce::String& password);
    LoginResult refreshToken(const juce::String& refreshToken);
    bool validateToken(const juce::String& token);

    //==============================================================================
    // Projects
    std::vector<ProjectInfo> fetchProjects(const juce::String& authToken);
    std::vector<juce::String> fetchTrackPaths(const juce::String& authToken, const juce::String& projectId);

    //==============================================================================
    // Storage
    juce::String getSignedUrl(const juce::String& authToken, const juce::String& bucket, const juce::String& path);
    bool downloadFile(const juce::String& signedUrl, juce::File& outputFile);
    bool uploadFile(const juce::String& authToken, const juce::String& bucket, const juce::String& path, const juce::File& file);

private:
    juce::String supabaseUrl;
    juce::String anonKey;

    // HTTP Helper
    nlohmann::json makeRequest(const juce::String& endpoint, const juce::String& method, const nlohmann::json& body, const juce::String& authToken);
    static size_t writeCallback(char* ptr, size_t size, size_t nmemb, std::string* data);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SupabaseClient)
};
```

```cpp
// ============================================
// SupabaseClient.cpp (Key Methods)
// ============================================
#include "SupabaseClient.h"

SupabaseClient::SupabaseClient(const juce::String& url, const juce::String& key)
    : supabaseUrl(url), anonKey(key)
{
    curl_global_init(CURL_GLOBAL_DEFAULT);
}

SupabaseClient::~SupabaseClient()
{
    curl_global_cleanup();
}

SupabaseClient::LoginResult SupabaseClient::login(const juce::String& email, const juce::String& password)
{
    nlohmann::json body = {
        {"email", email.toStdString()},
        {"password", password.toStdString()}
    };

    try {
        auto response = makeRequest("/auth/v1/token?grant_type=password", "POST", body, "");

        return {
            true,
            juce::String(response["access_token"].get<std::string>()),
            juce::String(response["refresh_token"].get<std::string>()),
            ""
        };
    } catch (const std::exception& e) {
        return { false, "", "", e.what() };
    }
}

std::vector<ProjectInfo> SupabaseClient::fetchProjects(const juce::String& authToken)
{
    std::vector<ProjectInfo> projects;

    try {
        auto response = makeRequest("/rest/v1/projects?select=*,tracks(id)", "GET", {}, authToken);

        for (const auto& item : response) {
            ProjectInfo project;
            project.id = juce::String(item["id"].get<std::string>());
            project.title = juce::String(item["title"].get<std::string>());
            project.description = juce::String(item.value("description", ""));
            project.bpm = item.value("bpm", 120);
            project.status = juce::String(item.value("status", "draft"));

            // Extract track IDs
            if (item.contains("tracks")) {
                for (const auto& track : item["tracks"]) {
                    project.trackIds.push_back(juce::String(track["id"].get<std::string>()));
                }
            }

            projects.push_back(project);
        }
    } catch (const std::exception& e) {
        DBG("Error fetching projects: " + juce::String(e.what()));
    }

    return projects;
}

juce::String SupabaseClient::getSignedUrl(const juce::String& authToken, const juce::String& bucket, const juce::String& path)
{
    nlohmann::json body = {
        {"expiresIn", 3600} // 1 hour
    };

    try {
        auto endpoint = "/storage/v1/object/sign/" + bucket + "/" + path;
        auto response = makeRequest(endpoint, "POST", body, authToken);

        return juce::String(response["signedURL"].get<std::string>());
    } catch (const std::exception& e) {
        DBG("Error getting signed URL: " + juce::String(e.what()));
        return "";
    }
}

bool SupabaseClient::downloadFile(const juce::String& signedUrl, juce::File& outputFile)
{
    CURL* curl = curl_easy_init();
    if (!curl) return false;

    juce::FileOutputStream stream(outputFile);
    if (!stream.openedOk()) return false;

    std::string response;

    curl_easy_setopt(curl, CURLOPT_URL, signedUrl.toRawUTF8());
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, +[](char* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
        auto* stream = static_cast<juce::FileOutputStream*>(userdata);
        stream->write(ptr, size * nmemb);
        return size * nmemb;
    });
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &stream);

    CURLcode res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);

    stream.flush();

    return res == CURLE_OK;
}

nlohmann::json SupabaseClient::makeRequest(const juce::String& endpoint, const juce::String& method, const nlohmann::json& body, const juce::String& authToken)
{
    CURL* curl = curl_easy_init();
    if (!curl) throw std::runtime_error("CURL init failed");

    juce::String url = supabaseUrl + endpoint;
    std::string response;

    // Headers
    struct curl_slist* headers = NULL;
    headers = curl_slist_append(headers, ("apikey: " + anonKey).toRawUTF8());
    if (authToken.isNotEmpty()) {
        headers = curl_slist_append(headers, ("Authorization: Bearer " + authToken).toRawUTF8());
    }
    headers = curl_slist_append(headers, "Content-Type: application/json");

    // Options
    curl_easy_setopt(curl, CURLOPT_URL, url.toRawUTF8());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

    if (method == "POST" || method == "PATCH") {
        std::string bodyStr = body.dump();
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, bodyStr.c_str());
        if (method == "PATCH") {
            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PATCH");
        }
    } else if (method == "DELETE") {
        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
    }

    CURLcode res = curl_easy_perform(curl);

    curl_slist_free_all(headers);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        throw std::runtime_error("CURL request failed: " + std::string(curl_easy_strerror(res)));
    }

    return nlohmann::json::parse(response);
}

size_t SupabaseClient::writeCallback(char* ptr, size_t size, size_t nmemb, std::string* data)
{
    data->append(ptr, size * nmemb);
    return size * nmemb;
}
```

---

### 4. AuthManager (OAuth Flow)

```cpp
// ============================================
// AuthManager.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include "SupabaseClient.h"

class AuthManager
{
public:
    AuthManager(SupabaseClient& client);

    // OAuth Flow
    void startOAuthFlow(std::function<void(bool)> callback);
    void handleCallback(const juce::String& callbackUrl);

    // State
    bool isAuthenticated() const { return !accessToken.isEmpty(); }
    juce::String getAccessToken() const { return accessToken; }

    // Persistence
    juce::MemoryBlock getState() const;
    void setState(const void* data, int size);

    // Logout
    void logout();

private:
    SupabaseClient& supabaseClient;
    juce::String accessToken;
    juce::String refreshToken;
    juce::String csrfState;

    std::function<void(bool)> loginCallback;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AuthManager)
};
```

```cpp
// ============================================
// AuthManager.cpp
// ============================================
#include "AuthManager.h"

AuthManager::AuthManager(SupabaseClient& client)
    : supabaseClient(client)
{
}

void AuthManager::startOAuthFlow(std::function<void(bool)> callback)
{
    loginCallback = callback;

    // Generate CSRF state
    csrfState = juce::Uuid().toString();

    // Open browser for OAuth
    juce::String oauthUrl = "https://degixdaw.com/vst-auth?state=" + csrfState;
    juce::URL(oauthUrl).launchInDefaultBrowser();

    // Start listening for callback (custom URL scheme: degixdaw://auth)
    // Implementation depends on platform (Windows registry, macOS URL scheme handler)
}

void AuthManager::handleCallback(const juce::String& callbackUrl)
{
    // Parse callback URL
    // Example: degixdaw://auth?token=xxx&state=yyy

    juce::URL url(callbackUrl);
    auto token = url.getParameterValue("token");
    auto state = url.getParameterValue("state");

    // Verify CSRF state
    if (state != csrfState) {
        if (loginCallback) loginCallback(false);
        return;
    }

    // Validate token
    if (supabaseClient.validateToken(token)) {
        accessToken = token;
        if (loginCallback) loginCallback(true);
    } else {
        if (loginCallback) loginCallback(false);
    }
}

juce::MemoryBlock AuthManager::getState() const
{
    juce::MemoryBlock block;
    juce::MemoryOutputStream stream(block, false);

    // Write tokens (encrypted in production!)
    stream.writeString(accessToken);
    stream.writeString(refreshToken);

    return block;
}

void AuthManager::setState(const void* data, int size)
{
    juce::MemoryInputStream stream(data, size, false);

    accessToken = stream.readString();
    refreshToken = stream.readString();
}

void AuthManager::logout()
{
    accessToken = "";
    refreshToken = "";
}
```

---

## üîß CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)

project(DegixDAW VERSION 1.0.0)

# JUCE
add_subdirectory(JUCE)

# Plugin
juce_add_plugin(DegixDAW
    COMPANY_NAME "DegixDAW"
    IS_SYNTH FALSE
    NEEDS_MIDI_INPUT FALSE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    EDITOR_WANTS_KEYBOARD_FOCUS TRUE
    COPY_PLUGIN_AFTER_BUILD TRUE
    PLUGIN_MANUFACTURER_CODE Dgxd
    PLUGIN_CODE Dxdw
    FORMATS VST3 Standalone
    PRODUCT_NAME "DegixDAW"
)

# Source Files
target_sources(DegixDAW PRIVATE
    Source/PluginProcessor.cpp
    Source/PluginEditor.cpp
    Source/SupabaseClient.cpp
    Source/AuthManager.cpp
    Source/ProjectManager.cpp
    Source/FileDownloader.cpp
    Source/FileUploader.cpp
)

# Dependencies
find_package(CURL REQUIRED)

# nlohmann/json (header-only)
include(FetchContent)
FetchContent_Declare(json URL https://github.com/nlohmann/json/releases/download/v3.11.2/json.tar.xz)
FetchContent_MakeAvailable(json)

# Link Libraries
target_link_libraries(DegixDAW
    PRIVATE
        juce::juce_audio_processors
        juce::juce_audio_utils
        juce::juce_gui_basics
        CURL::libcurl
        nlohmann_json::nlohmann_json
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags
)

# Compiler Definitions
target_compile_definitions(DegixDAW
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=1
        JUCE_VST3_CAN_REPLACE_VST2=0
)
```

---

## üöÄ Build Instructions

### Windows (MSVC 2022)

```bash
# Prerequisites:
# - Visual Studio 2022 with C++ tools
# - CMake 3.15+
# - Git (for JUCE submodule)

# Clone & Setup
cd vst-plugin
git submodule update --init --recursive

# Generate Visual Studio project
cmake -B build -G "Visual Studio 17 2022"

# Build
cmake --build build --config Release

# Output:
# build/DegixDAW_artefacts/Release/VST3/DegixDAW.vst3

# Install to DAW
# Copy .vst3 folder to:
# C:\Program Files\Common Files\VST3\
```

### macOS (Xcode)

```bash
# Prerequisites:
# - Xcode with Command Line Tools
# - CMake

cmake -B build -G "Xcode"
cmake --build build --config Release

# Output:
# build/DegixDAW_artefacts/Release/VST3/DegixDAW.vst3

# Install:
# ~/Library/Audio/Plug-Ins/VST3/
```

---

## üß™ Testing

### Manual Testing in Cubase

```
1. Install VST3 to correct folder
2. Open Cubase 13
3. Studio ‚Üí VST Plug-in Manager ‚Üí Refresh
4. Add ‚Üí Instruments ‚Üí DegixDAW
5. Open Plugin UI
6. Click "Login" ‚Üí Browser opens
7. Log in ‚Üí Callback to VST
8. See project list
9. Select project ‚Üí "Load to DAW"
10. Verify MIDI/Audio imported
```

---

## üì¶ Distribution

### Windows Installer (Inno Setup)

```iss
[Setup]
AppName=DegixDAW VST Plugin
AppVersion=1.0.0
DefaultDirName={commonpf}\Common Files\VST3
OutputBaseFilename=DegixDAW-Setup-v1.0.0

[Files]
Source: "build\DegixDAW_artefacts\Release\VST3\DegixDAW.vst3\*"; DestDir: "{app}\DegixDAW.vst3"; Flags: recursesubdirs
```

---

**See also:**
- [03_DATA_FLOW.md](03_DATA_FLOW.md) - VST communication flows
- [04_STORAGE_STRATEGY.md](04_STORAGE_STRATEGY.md) - File download/upload
- [06_DEPLOYMENT.md](06_DEPLOYMENT.md) - CI/CD for VST builds
