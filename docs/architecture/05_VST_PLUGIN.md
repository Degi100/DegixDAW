# VST Plugin Architecture - DegixDAW

**Erstellt:** 2025-10-17
**Version:** 1.0

---

## 🔌 VST Plugin Overview

### Purpose

Das DegixDAW VST3 Plugin dient als **Bridge zwischen DAW und Supabase Cloud**.

```
┌─────────────────────────────────────────────────────────────────────┐
│  VST Plugin Flow                                                     │
└─────────────────────────────────────────────────────────────────────┘

User in DAW (Cubase)
  │
  ├─ Opens VST Plugin
  ├─ Logs in via Browser OAuth
  ├─ Sees list of Projects
  ├─ Selects Project
  ├─ Downloads MIDI + Audio to DAW
  ├─ Works on Project (mix, add FX)
  ├─ Renders Mixdown
  └─ Uploads Mixdown back to Cloud
```

### Key Features

```
✅ Login via OAuth (Browser-based)
✅ Fetch User Projects from Supabase
✅ Download MIDI files to DAW
✅ Download Audio files to DAW
✅ Upload Mixdowns to Cloud
✅ Browse & Download Presets
✅ Auto-token refresh
```

---

## 🏗️ JUCE Project Structure

### Directory Layout

```
vst-plugin/
├── CMakeLists.txt              # CMake build config
├── JUCE/                       # JUCE submodule
├── Source/
│   ├── PluginProcessor.h/cpp   # Audio processing logic
│   ├── PluginEditor.h/cpp      # UI component
│   ├── SupabaseClient.h/cpp    # HTTP client for Supabase
│   ├── AuthManager.h/cpp       # OAuth flow
│   ├── ProjectManager.h/cpp    # Project CRUD
│   ├── FileDownloader.h/cpp    # Download logic
│   ├── FileUploader.h/cpp      # Upload logic
│   ├── LookAndFeel.h/cpp       # Custom UI theme
│   └── Utils.h/cpp             # Helper functions
├── Resources/
│   └── logo.png                # Plugin icon
└── builds/
    └── VisualStudio2022/       # Generated by CMake
```

---

## 🎛️ Plugin Components

### 1. PluginProcessor (Audio Core)

```cpp
// ============================================
// PluginProcessor.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include "SupabaseClient.h"
#include "AuthManager.h"
#include "ProjectManager.h"

class DegixDAWProcessor : public juce::AudioProcessor
{
public:
    DegixDAWProcessor();
    ~DegixDAWProcessor() override;

    //==============================================================================
    // Audio Processing (Passthrough - no audio effects)
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    //==============================================================================
    // Plugin State
    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;

    //==============================================================================
    // Editor
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    //==============================================================================
    // Plugin Info
    const juce::String getName() const override { return "DegixDAW"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    //==============================================================================
    // Programs (not used)
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return {}; }
    void changeProgramName(int, const juce::String&) override {}

    //==============================================================================
    // DegixDAW API
    AuthManager& getAuthManager() { return authManager; }
    ProjectManager& getProjectManager() { return projectManager; }
    SupabaseClient& getSupabaseClient() { return supabaseClient; }

private:
    //==============================================================================
    // Components
    AuthManager authManager;
    ProjectManager projectManager;
    SupabaseClient supabaseClient;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DegixDAWProcessor)
};
```

```cpp
// ============================================
// PluginProcessor.cpp
// ============================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

DegixDAWProcessor::DegixDAWProcessor()
    : AudioProcessor(BusesProperties()) // No audio buses (not an effect)
    , supabaseClient("https://your-project.supabase.co", "your-anon-key")
    , authManager(supabaseClient)
    , projectManager(supabaseClient)
{
}

DegixDAWProcessor::~DegixDAWProcessor()
{
}

void DegixDAWProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // Not processing audio
}

void DegixDAWProcessor::releaseResources()
{
    // Nothing to release
}

void DegixDAWProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    // Passthrough - don't modify audio
    juce::ignoreUnused(buffer, midiMessages);
}

void DegixDAWProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    // Save auth token + selected project ID
    auto state = authManager.getState();
    destData.append(state.data(), state.size());
}

void DegixDAWProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    // Restore auth token + selected project ID
    authManager.setState(data, sizeInBytes);
}

juce::AudioProcessorEditor* DegixDAWProcessor::createEditor()
{
    return new DegixDAWEditor(*this);
}

// Plugin Entry Point
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new DegixDAWProcessor();
}
```

---

### 2. PluginEditor (UI)

```cpp
// ============================================
// PluginEditor.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include "PluginProcessor.h"

class DegixDAWEditor : public juce::AudioProcessorEditor,
                       public juce::Button::Listener,
                       public juce::ListBoxModel
{
public:
    DegixDAWEditor(DegixDAWProcessor&);
    ~DegixDAWEditor() override;

    //==============================================================================
    void paint(juce::Graphics&) override;
    void resized() override;

    //==============================================================================
    // Button Listener
    void buttonClicked(juce::Button*) override;

    //==============================================================================
    // ListBox Model
    int getNumRows() override;
    void paintListBoxItem(int rowNumber, juce::Graphics&, int width, int height, bool rowIsSelected) override;
    void listBoxItemClicked(int row, const juce::MouseEvent&) override;

private:
    DegixDAWProcessor& processor;

    // UI Components
    juce::Label titleLabel;
    juce::TextButton loginButton{"Login"};
    juce::TextButton logoutButton{"Logout"};
    juce::TextButton refreshButton{"Refresh Projects"};
    juce::TextButton loadToDAWButton{"Load to DAW"};
    juce::TextButton uploadMixdownButton{"Upload Mixdown"};
    juce::ListBox projectListBox;
    juce::Label statusLabel;

    // State
    std::vector<ProjectInfo> projects;
    int selectedProjectIndex = -1;

    // Helper
    void updateUI();
    void login();
    void logout();
    void refreshProjects();
    void loadProjectToDAW();
    void uploadMixdown();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(DegixDAWEditor)
};
```

```cpp
// ============================================
// PluginEditor.cpp
// ============================================
#include "PluginEditor.h"

DegixDAWEditor::DegixDAWEditor(DegixDAWProcessor& p)
    : AudioProcessorEditor(&p)
    , processor(p)
{
    setSize(600, 500);

    // Title
    titleLabel.setText("DegixDAW", juce::dontSendNotification);
    titleLabel.setFont(juce::Font(24.0f, juce::Font::bold));
    titleLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(titleLabel);

    // Buttons
    loginButton.addListener(this);
    logoutButton.addListener(this);
    refreshButton.addListener(this);
    loadToDAWButton.addListener(this);
    uploadMixdownButton.addListener(this);

    addAndMakeVisible(loginButton);
    addAndMakeVisible(logoutButton);
    addAndMakeVisible(refreshButton);
    addAndMakeVisible(loadToDAWButton);
    addAndMakeVisible(uploadMixdownButton);

    // Project List
    projectListBox.setModel(this);
    addAndMakeVisible(projectListBox);

    // Status
    statusLabel.setText("Not logged in", juce::dontSendNotification);
    addAndMakeVisible(statusLabel);

    updateUI();
}

DegixDAWEditor::~DegixDAWEditor()
{
}

void DegixDAWEditor::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colours::darkgrey);
}

void DegixDAWEditor::resized()
{
    auto bounds = getLocalBounds().reduced(10);

    titleLabel.setBounds(bounds.removeFromTop(40));
    bounds.removeFromTop(10);

    auto buttonArea = bounds.removeFromTop(40);
    loginButton.setBounds(buttonArea.removeFromLeft(100).reduced(2));
    logoutButton.setBounds(buttonArea.removeFromLeft(100).reduced(2));
    refreshButton.setBounds(buttonArea.removeFromLeft(120).reduced(2));
    loadToDAWButton.setBounds(buttonArea.removeFromLeft(120).reduced(2));
    uploadMixdownButton.setBounds(buttonArea.removeFromLeft(140).reduced(2));

    bounds.removeFromTop(10);
    projectListBox.setBounds(bounds.removeFromTop(300));

    bounds.removeFromTop(10);
    statusLabel.setBounds(bounds.removeFromTop(30));
}

void DegixDAWEditor::buttonClicked(juce::Button* button)
{
    if (button == &loginButton) login();
    else if (button == &logoutButton) logout();
    else if (button == &refreshButton) refreshProjects();
    else if (button == &loadToDAWButton) loadProjectToDAW();
    else if (button == &uploadMixdownButton) uploadMixdown();
}

void DegixDAWEditor::login()
{
    processor.getAuthManager().startOAuthFlow([this](bool success) {
        if (success) {
            statusLabel.setText("Logged in!", juce::dontSendNotification);
            refreshProjects();
        } else {
            statusLabel.setText("Login failed", juce::dontSendNotification);
        }
        updateUI();
    });
}

void DegixDAWEditor::logout()
{
    processor.getAuthManager().logout();
    projects.clear();
    projectListBox.updateContent();
    statusLabel.setText("Logged out", juce::dontSendNotification);
    updateUI();
}

void DegixDAWEditor::refreshProjects()
{
    statusLabel.setText("Loading projects...", juce::dontSendNotification);

    processor.getProjectManager().fetchProjects([this](std::vector<ProjectInfo> fetchedProjects) {
        projects = fetchedProjects;
        projectListBox.updateContent();
        statusLabel.setText(juce::String(projects.size()) + " projects loaded", juce::dontSendNotification);
    });
}

void DegixDAWEditor::loadProjectToDAW()
{
    if (selectedProjectIndex < 0 || selectedProjectIndex >= (int)projects.size()) {
        statusLabel.setText("Select a project first", juce::dontSendNotification);
        return;
    }

    auto& project = projects[selectedProjectIndex];
    statusLabel.setText("Loading project to DAW...", juce::dontSendNotification);

    processor.getProjectManager().loadProjectToDAW(project, [this](bool success) {
        if (success) {
            statusLabel.setText("Project loaded!", juce::dontSendNotification);
        } else {
            statusLabel.setText("Failed to load project", juce::dontSendNotification);
        }
    });
}

void DegixDAWEditor::uploadMixdown()
{
    // File chooser for WAV file
    auto chooser = std::make_shared<juce::FileChooser>("Select Mixdown", juce::File(), "*.wav");

    chooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this, chooser](const juce::FileChooser& fc) {
            auto file = fc.getResult();
            if (file.existsAsFile()) {
                statusLabel.setText("Uploading mixdown...", juce::dontSendNotification);

                processor.getProjectManager().uploadMixdown(projects[selectedProjectIndex], file, [this](bool success) {
                    if (success) {
                        statusLabel.setText("Mixdown uploaded!", juce::dontSendNotification);
                    } else {
                        statusLabel.setText("Upload failed", juce::dontSendNotification);
                    }
                });
            }
        });
}

void DegixDAWEditor::updateUI()
{
    bool isLoggedIn = processor.getAuthManager().isAuthenticated();
    loginButton.setEnabled(!isLoggedIn);
    logoutButton.setEnabled(isLoggedIn);
    refreshButton.setEnabled(isLoggedIn);
    loadToDAWButton.setEnabled(isLoggedIn && selectedProjectIndex >= 0);
    uploadMixdownButton.setEnabled(isLoggedIn && selectedProjectIndex >= 0);
}

int DegixDAWEditor::getNumRows()
{
    return (int)projects.size();
}

void DegixDAWEditor::paintListBoxItem(int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowIsSelected)
        g.fillAll(juce::Colours::lightblue);
    else
        g.fillAll(rowNumber % 2 == 0 ? juce::Colours::white : juce::Colours::lightgrey);

    if (rowNumber < (int)projects.size()) {
        auto& project = projects[rowNumber];
        g.setColour(juce::Colours::black);
        g.drawText(project.title, 10, 0, width - 10, height, juce::Justification::centredLeft);
    }
}

void DegixDAWEditor::listBoxItemClicked(int row, const juce::MouseEvent&)
{
    selectedProjectIndex = row;
    updateUI();
}
```

---

### 3. SupabaseClient (HTTP Client)

```cpp
// ============================================
// SupabaseClient.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include <curl/curl.h>
#include <nlohmann/json.hpp>

struct ProjectInfo {
    juce::String id;
    juce::String title;
    juce::String description;
    int bpm;
    juce::String status;
    std::vector<juce::String> trackIds;
};

class SupabaseClient
{
public:
    SupabaseClient(const juce::String& supabaseUrl, const juce::String& anonKey);
    ~SupabaseClient();

    //==============================================================================
    // Auth
    struct LoginResult {
        bool success;
        juce::String accessToken;
        juce::String refreshToken;
        juce::String errorMessage;
    };
    LoginResult login(const juce::String& email, const juce::String& password);
    LoginResult refreshToken(const juce::String& refreshToken);
    bool validateToken(const juce::String& token);

    //==============================================================================
    // Projects
    std::vector<ProjectInfo> fetchProjects(const juce::String& authToken);
    std::vector<juce::String> fetchTrackPaths(const juce::String& authToken, const juce::String& projectId);

    //==============================================================================
    // Storage
    juce::String getSignedUrl(const juce::String& authToken, const juce::String& bucket, const juce::String& path);
    bool downloadFile(const juce::String& signedUrl, juce::File& outputFile);
    bool uploadFile(const juce::String& authToken, const juce::String& bucket, const juce::String& path, const juce::File& file);

private:
    juce::String supabaseUrl;
    juce::String anonKey;

    // HTTP Helper
    nlohmann::json makeRequest(const juce::String& endpoint, const juce::String& method, const nlohmann::json& body, const juce::String& authToken);
    static size_t writeCallback(char* ptr, size_t size, size_t nmemb, std::string* data);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SupabaseClient)
};
```

```cpp
// ============================================
// SupabaseClient.cpp (Key Methods)
// ============================================
#include "SupabaseClient.h"

SupabaseClient::SupabaseClient(const juce::String& url, const juce::String& key)
    : supabaseUrl(url), anonKey(key)
{
    curl_global_init(CURL_GLOBAL_DEFAULT);
}

SupabaseClient::~SupabaseClient()
{
    curl_global_cleanup();
}

SupabaseClient::LoginResult SupabaseClient::login(const juce::String& email, const juce::String& password)
{
    nlohmann::json body = {
        {"email", email.toStdString()},
        {"password", password.toStdString()}
    };

    try {
        auto response = makeRequest("/auth/v1/token?grant_type=password", "POST", body, "");

        return {
            true,
            juce::String(response["access_token"].get<std::string>()),
            juce::String(response["refresh_token"].get<std::string>()),
            ""
        };
    } catch (const std::exception& e) {
        return { false, "", "", e.what() };
    }
}

std::vector<ProjectInfo> SupabaseClient::fetchProjects(const juce::String& authToken)
{
    std::vector<ProjectInfo> projects;

    try {
        auto response = makeRequest("/rest/v1/projects?select=*,tracks(id)", "GET", {}, authToken);

        for (const auto& item : response) {
            ProjectInfo project;
            project.id = juce::String(item["id"].get<std::string>());
            project.title = juce::String(item["title"].get<std::string>());
            project.description = juce::String(item.value("description", ""));
            project.bpm = item.value("bpm", 120);
            project.status = juce::String(item.value("status", "draft"));

            // Extract track IDs
            if (item.contains("tracks")) {
                for (const auto& track : item["tracks"]) {
                    project.trackIds.push_back(juce::String(track["id"].get<std::string>()));
                }
            }

            projects.push_back(project);
        }
    } catch (const std::exception& e) {
        DBG("Error fetching projects: " + juce::String(e.what()));
    }

    return projects;
}

juce::String SupabaseClient::getSignedUrl(const juce::String& authToken, const juce::String& bucket, const juce::String& path)
{
    nlohmann::json body = {
        {"expiresIn", 3600} // 1 hour
    };

    try {
        auto endpoint = "/storage/v1/object/sign/" + bucket + "/" + path;
        auto response = makeRequest(endpoint, "POST", body, authToken);

        return juce::String(response["signedURL"].get<std::string>());
    } catch (const std::exception& e) {
        DBG("Error getting signed URL: " + juce::String(e.what()));
        return "";
    }
}

bool SupabaseClient::downloadFile(const juce::String& signedUrl, juce::File& outputFile)
{
    CURL* curl = curl_easy_init();
    if (!curl) return false;

    juce::FileOutputStream stream(outputFile);
    if (!stream.openedOk()) return false;

    std::string response;

    curl_easy_setopt(curl, CURLOPT_URL, signedUrl.toRawUTF8());
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, +[](char* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
        auto* stream = static_cast<juce::FileOutputStream*>(userdata);
        stream->write(ptr, size * nmemb);
        return size * nmemb;
    });
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &stream);

    CURLcode res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);

    stream.flush();

    return res == CURLE_OK;
}

nlohmann::json SupabaseClient::makeRequest(const juce::String& endpoint, const juce::String& method, const nlohmann::json& body, const juce::String& authToken)
{
    CURL* curl = curl_easy_init();
    if (!curl) throw std::runtime_error("CURL init failed");

    juce::String url = supabaseUrl + endpoint;
    std::string response;

    // Headers
    struct curl_slist* headers = NULL;
    headers = curl_slist_append(headers, ("apikey: " + anonKey).toRawUTF8());
    if (authToken.isNotEmpty()) {
        headers = curl_slist_append(headers, ("Authorization: Bearer " + authToken).toRawUTF8());
    }
    headers = curl_slist_append(headers, "Content-Type: application/json");

    // Options
    curl_easy_setopt(curl, CURLOPT_URL, url.toRawUTF8());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

    if (method == "POST" || method == "PATCH") {
        std::string bodyStr = body.dump();
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, bodyStr.c_str());
        if (method == "PATCH") {
            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PATCH");
        }
    } else if (method == "DELETE") {
        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
    }

    CURLcode res = curl_easy_perform(curl);

    curl_slist_free_all(headers);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        throw std::runtime_error("CURL request failed: " + std::string(curl_easy_strerror(res)));
    }

    return nlohmann::json::parse(response);
}

size_t SupabaseClient::writeCallback(char* ptr, size_t size, size_t nmemb, std::string* data)
{
    data->append(ptr, size * nmemb);
    return size * nmemb;
}
```

---

### 4. AuthManager (OAuth Flow)

```cpp
// ============================================
// AuthManager.h
// ============================================
#pragma once

#include <JuceHeader.h>
#include "SupabaseClient.h"

class AuthManager
{
public:
    AuthManager(SupabaseClient& client);

    // OAuth Flow
    void startOAuthFlow(std::function<void(bool)> callback);
    void handleCallback(const juce::String& callbackUrl);

    // State
    bool isAuthenticated() const { return !accessToken.isEmpty(); }
    juce::String getAccessToken() const { return accessToken; }

    // Persistence
    juce::MemoryBlock getState() const;
    void setState(const void* data, int size);

    // Logout
    void logout();

private:
    SupabaseClient& supabaseClient;
    juce::String accessToken;
    juce::String refreshToken;
    juce::String csrfState;

    std::function<void(bool)> loginCallback;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AuthManager)
};
```

```cpp
// ============================================
// AuthManager.cpp
// ============================================
#include "AuthManager.h"

AuthManager::AuthManager(SupabaseClient& client)
    : supabaseClient(client)
{
}

void AuthManager::startOAuthFlow(std::function<void(bool)> callback)
{
    loginCallback = callback;

    // Generate CSRF state
    csrfState = juce::Uuid().toString();

    // Open browser for OAuth
    juce::String oauthUrl = "https://degixdaw.com/vst-auth?state=" + csrfState;
    juce::URL(oauthUrl).launchInDefaultBrowser();

    // Start listening for callback (custom URL scheme: degixdaw://auth)
    // Implementation depends on platform (Windows registry, macOS URL scheme handler)
}

void AuthManager::handleCallback(const juce::String& callbackUrl)
{
    // Parse callback URL
    // Example: degixdaw://auth?token=xxx&state=yyy

    juce::URL url(callbackUrl);
    auto token = url.getParameterValue("token");
    auto state = url.getParameterValue("state");

    // Verify CSRF state
    if (state != csrfState) {
        if (loginCallback) loginCallback(false);
        return;
    }

    // Validate token
    if (supabaseClient.validateToken(token)) {
        accessToken = token;
        if (loginCallback) loginCallback(true);
    } else {
        if (loginCallback) loginCallback(false);
    }
}

juce::MemoryBlock AuthManager::getState() const
{
    juce::MemoryBlock block;
    juce::MemoryOutputStream stream(block, false);

    // Write tokens (encrypted in production!)
    stream.writeString(accessToken);
    stream.writeString(refreshToken);

    return block;
}

void AuthManager::setState(const void* data, int size)
{
    juce::MemoryInputStream stream(data, size, false);

    accessToken = stream.readString();
    refreshToken = stream.readString();
}

void AuthManager::logout()
{
    accessToken = "";
    refreshToken = "";
}
```

---

## 🔧 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)

project(DegixDAW VERSION 1.0.0)

# JUCE
add_subdirectory(JUCE)

# Plugin
juce_add_plugin(DegixDAW
    COMPANY_NAME "DegixDAW"
    IS_SYNTH FALSE
    NEEDS_MIDI_INPUT FALSE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    EDITOR_WANTS_KEYBOARD_FOCUS TRUE
    COPY_PLUGIN_AFTER_BUILD TRUE
    PLUGIN_MANUFACTURER_CODE Dgxd
    PLUGIN_CODE Dxdw
    FORMATS VST3 Standalone
    PRODUCT_NAME "DegixDAW"
)

# Source Files
target_sources(DegixDAW PRIVATE
    Source/PluginProcessor.cpp
    Source/PluginEditor.cpp
    Source/SupabaseClient.cpp
    Source/AuthManager.cpp
    Source/ProjectManager.cpp
    Source/FileDownloader.cpp
    Source/FileUploader.cpp
)

# Dependencies
find_package(CURL REQUIRED)

# nlohmann/json (header-only)
include(FetchContent)
FetchContent_Declare(json URL https://github.com/nlohmann/json/releases/download/v3.11.2/json.tar.xz)
FetchContent_MakeAvailable(json)

# Link Libraries
target_link_libraries(DegixDAW
    PRIVATE
        juce::juce_audio_processors
        juce::juce_audio_utils
        juce::juce_gui_basics
        CURL::libcurl
        nlohmann_json::nlohmann_json
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags
)

# Compiler Definitions
target_compile_definitions(DegixDAW
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=1
        JUCE_VST3_CAN_REPLACE_VST2=0
)
```

---

## 🚀 Build Instructions

### Windows (MSVC 2022)

```bash
# Prerequisites:
# - Visual Studio 2022 with C++ tools
# - CMake 3.15+
# - Git (for JUCE submodule)

# Clone & Setup
cd vst-plugin
git submodule update --init --recursive

# Generate Visual Studio project
cmake -B build -G "Visual Studio 17 2022"

# Build
cmake --build build --config Release

# Output:
# build/DegixDAW_artefacts/Release/VST3/DegixDAW.vst3

# Install to DAW
# Copy .vst3 folder to:
# C:\Program Files\Common Files\VST3\
```

### macOS (Xcode)

```bash
# Prerequisites:
# - Xcode with Command Line Tools
# - CMake

cmake -B build -G "Xcode"
cmake --build build --config Release

# Output:
# build/DegixDAW_artefacts/Release/VST3/DegixDAW.vst3

# Install:
# ~/Library/Audio/Plug-Ins/VST3/
```

---

## 🧪 Testing

### Manual Testing in Cubase

```
1. Install VST3 to correct folder
2. Open Cubase 13
3. Studio → VST Plug-in Manager → Refresh
4. Add → Instruments → DegixDAW
5. Open Plugin UI
6. Click "Login" → Browser opens
7. Log in → Callback to VST
8. See project list
9. Select project → "Load to DAW"
10. Verify MIDI/Audio imported
```

---

## 📦 Distribution

### Windows Installer (Inno Setup)

```iss
[Setup]
AppName=DegixDAW VST Plugin
AppVersion=1.0.0
DefaultDirName={commonpf}\Common Files\VST3
OutputBaseFilename=DegixDAW-Setup-v1.0.0

[Files]
Source: "build\DegixDAW_artefacts\Release\VST3\DegixDAW.vst3\*"; DestDir: "{app}\DegixDAW.vst3"; Flags: recursesubdirs
```

---

**See also:**
- [03_DATA_FLOW.md](03_DATA_FLOW.md) - VST communication flows
- [04_STORAGE_STRATEGY.md](04_STORAGE_STRATEGY.md) - File download/upload
- [06_DEPLOYMENT.md](06_DEPLOYMENT.md) - CI/CD for VST builds
